"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.getEmailFromPath = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const getEmailFromPath = (path) => {
    let fileFound;
    fs_1.default.readdirSync(path).forEach((file) => {
        if (fileFound !== undefined) {
            // break after getting first file
            return;
        }
        const fileType = file.split(".").pop();
        const filename = file.replace(/^.*[\\/]/, "").split(".")[0];
        if (filename === "index") {
            if (fileType === "mjml" || fileType === "html") {
                const fileContents = fs_1.default.readFileSync(`${path}/${file}`, "utf8");
                fileFound = { file: fileContents, type: fileType };
            }
        }
    });
    return fileFound;
};
exports.getEmailFromPath = getEmailFromPath;
const allowedPreviewEnvironments = ["deploy-preview", "branch-deploy", "dev"];
const isConfigValid = () => {
    if (process.env.NETLIFY_EMAILS_PROVIDER_API_KEY === undefined) {
        return false;
    }
    if (process.env.NETLIFY_EMAILS_PROVIDER === undefined) {
        return false;
    }
    if (process.env.NETLIFY_EMAILS_PROVIDER === "mailgun") {
        if (process.env.NETLIFY_EMAILS_MAILGUN_DOMAIN === undefined) {
            return false;
        }
        if (process.env.NETLIFY_EMAILS_MAILGUN_HOST_REGION === undefined) {
            return false;
        }
    }
    return true;
};
const handler = (event) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const { default: fetch } = yield Promise.resolve().then(() => __importStar(require("node-fetch")));
    console.log(`Email handler received email request from path ${event.rawUrl}`);
    const validConfig = isConfigValid();
    const providerApiKey = process.env.NETLIFY_EMAILS_PROVIDER_API_KEY;
    const providerName = process.env.NETLIFY_EMAILS_PROVIDER;
    const emailTemplatesDirectory = (_a = process.env.NETLIFY_EMAILS_DIRECTORY) !== null && _a !== void 0 ? _a : "./emails";
    const emailPath = (_b = event.rawUrl.match(/emails\/([A-z-]*)[?]?/)) === null || _b === void 0 ? void 0 : _b[1];
    // If missing configuration, render preview HTML and sending missing configuration object to window varialbe
    if (!validConfig) {
        return {
            statusCode: 200,
            body: `
        <html>
          <head>
          <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
          <script>
            hljs.highlightAll();
          </script>
          <link rel="stylesheet" href="https://netlify-integration-emails.netlify.app/main.css">
          <script>
          config = ${JSON.stringify({
                NETLIFY_EMAILS_PROVIDER: providerName,
                NETLIFY_EMAILS_PROVIDER_API_KEY: providerApiKey,
                NETLIFY_EMAILS_MAILGUN_DOMAIN: process.env.NETLIFY_EMAILS_MAILGUN_DOMAIN,
                NETLIFY_EMAILS_MAILGUN_HOST_REGION: process.env.NETLIFY_EMAILS_MAILGUN_HOST_REGION,
            })}
            siteId = ${JSON.stringify(process.env.SITE_ID)}
            templateName = ${JSON.stringify(emailPath)}
          </script>
          <script defer src='https://netlify-integration-emails.netlify.app/index.js'></script>
          </head>
          <div id='app'></div>
        </html>
        `,
        };
    }
    const showEmailPreview = allowedPreviewEnvironments.includes(process.env.CONTEXT);
    if (event.httpMethod === "GET" && showEmailPreview) {
        let emailTemplate;
        if (emailPath !== undefined) {
            // Return error if preview path is not a valid email path
            if (!fs_1.default.existsSync((0, path_1.join)(emailTemplatesDirectory, emailPath))) {
                console.log(`Preview path is not a valid email path - preview path received: ${emailPath}`);
                return {
                    statusCode: 400,
                    body: JSON.stringify({
                        message: `Preview path is not a valid email path - preview path received: ${emailPath}`,
                    }),
                };
            }
            emailTemplate = (0, exports.getEmailFromPath)((0, path_1.join)(emailTemplatesDirectory, emailPath));
            // If no email template found, return error
            if (emailTemplate === undefined) {
                console.log(`No email template found for preview path - preview path received: ${emailPath}. Please ensure that an index.mjml or index.html file exists in the email template folder.`);
                return {
                    statusCode: 400,
                    body: JSON.stringify({
                        message: `No email template found for preview path - preview path received: ${emailPath}`,
                    }),
                };
            }
        }
        const validEmailPaths = [];
        fs_1.default.readdirSync(emailTemplatesDirectory).forEach((template) => {
            // If index.html or index.mjml exists inside template folder, add to validEmailPaths
            if (fs_1.default.existsSync((0, path_1.join)(emailTemplatesDirectory, template, "index.html")) ||
                fs_1.default.existsSync((0, path_1.join)(emailTemplatesDirectory, template, "index.mjml"))) {
                validEmailPaths.push(template);
            }
        });
        return {
            statusCode: 200,
            body: `
        <html>
          <head>
          <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
          <script>
            hljs.highlightAll();
          </script>
          <link rel="stylesheet" href="https://netlify-integration-emails.netlify.app/main.css">
          <script>
            emailPaths =  ${JSON.stringify(validEmailPaths)}
            template = ${JSON.stringify(emailTemplate === null || emailTemplate === void 0 ? void 0 : emailTemplate.file)}
            templateType = ${JSON.stringify(emailTemplate === null || emailTemplate === void 0 ? void 0 : emailTemplate.type)}
            siteId = ${JSON.stringify(process.env.SITE_ID)}
            config = ${JSON.stringify({
                NETLIFY_EMAILS_PROVIDER: providerName,
                NETLIFY_EMAILS_PROVIDER_API_KEY: providerApiKey,
                NETLIFY_EMAILS_MAILGUN_DOMAIN: process.env.NETLIFY_EMAILS_MAILGUN_DOMAIN,
                NETLIFY_EMAILS_MAILGUN_HOST_REGION: process.env.NETLIFY_EMAILS_MAILGUN_HOST_REGION,
            })}
            url = ${JSON.stringify(process.env.URL)}
            templateName = ${JSON.stringify(emailPath)}
          </script>
          <script defer src='https://netlify-integration-emails.netlify.app/index.js'></script>
          </head>
          <div id='app'></div>
        </html>
        `,
            headers: {
                "Content-Type": "text/html",
            },
        };
    }
    if (process.env.NETLIFY_EMAILS_SECRET === undefined ||
        event.headers["netlify-emails-secret"] !== process.env.NETLIFY_EMAILS_SECRET) {
        console.log("No secret provided or secret does not match");
        return {
            statusCode: 403,
            body: JSON.stringify({
                message: "Request forbidden",
            }),
        };
    }
    if (event.body === null) {
        return {
            statusCode: 400,
            body: JSON.stringify({
                message: "Body required",
            }),
        };
    }
    const requestBody = JSON.parse(event.body);
    if (requestBody.from === undefined) {
        console.log("From address is required");
        return {
            statusCode: 400,
            body: JSON.stringify({
                message: "From address is required",
            }),
        };
    }
    if (requestBody.to === undefined) {
        console.log("To address is required");
        return {
            statusCode: 400,
            body: JSON.stringify({
                message: "To address is required",
            }),
        };
    }
    if (emailPath === undefined) {
        console.error(`Email path is undefined`);
        return {
            statusCode: 404,
            body: JSON.stringify({
                message: `Email path is undefined`,
            }),
        };
    }
    const fullEmailPath = `${emailTemplatesDirectory}/${emailPath}`;
    const directoryExists = fs_1.default.existsSync(fullEmailPath);
    if (!directoryExists) {
        console.error(`Email directory does not exist: ${fullEmailPath}`);
        return {
            statusCode: 404,
            body: JSON.stringify({
                message: `Email path ${fullEmailPath} does not exist`,
            }),
        };
    }
    const email = (0, exports.getEmailFromPath)(fullEmailPath);
    if (email === undefined) {
        console.error(`No email file found in directory: ${fullEmailPath}`);
        return {
            statusCode: 404,
            body: JSON.stringify({
                message: `No email file found in directory: ${fullEmailPath}`,
            }),
        };
    }
    const renderResponse = yield fetch("https://netlify-integration-emails.netlify.app/.netlify/functions/render?showParamaterDictionary=true", {
        method: "POST",
        headers: {
            "site-id": process.env.SITE_ID,
        },
        body: JSON.stringify({
            template: email.file,
            type: email.type,
            parameters: requestBody.parameters,
            showParamatersDictionary: false,
        }),
    });
    const renderResponseJson = (yield renderResponse.json());
    const renderedTemplate = renderResponseJson.html;
    const response = yield fetch("https://test-netlify-integration-emails.netlify.app/.netlify/functions/send", {
        method: "POST",
        headers: {
            "site-id": process.env.SITE_ID,
            "content-type": "application/json",
        },
        body: JSON.stringify({
            configuration: {
                providerName,
                apiKey: providerApiKey,
                mailgunDomain: process.env.NETLIFY_EMAILS_MAILGUN_DOMAIN,
                mailgunHostRegion: process.env.NETLIFY_EMAILS_MAILGUN_HOST_REGION,
            },
            request: {
                from: requestBody.from,
                to: requestBody.to,
                cc: requestBody.cc,
                bcc: requestBody.bcc,
                subject: (_c = requestBody.subject) !== null && _c !== void 0 ? _c : "",
                html: renderedTemplate,
                attachments: requestBody.attachments,
            },
        }),
    });
    const responseText = yield response.text();
    return {
        statusCode: response.status,
        body: JSON.stringify({
            message: responseText,
        }),
    };
});
exports.handler = handler;
